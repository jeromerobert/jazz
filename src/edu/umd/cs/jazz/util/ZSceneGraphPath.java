/**
 * Copyright (C) 1998-2000 by University of Maryland, College Park, MD 20742, USA
 * All rights reserved.
 */

package edu.umd.cs.jazz.util;

import java.io.*;
import java.awt.geom.*;

import edu.umd.cs.jazz.*;

/**
 * <b>ZSceneGraphPath</b> represents a unique path in a scene graph
 * from a top-level camera to a terminal node. The path is typically used
 * in event handlers to determine what object is under the mouse pointer,
 * and what camera(s) that object was rendered within.  The path is
 * typically generated by @link(ZDrawingSurface#pick).  The terminal node
 * can be a node or visual component, but is typically a visual component,
 * or null.  One exception to this is that if a group's children are not
 * pickable than the group itself will be the terminal object if one
 * if its children was actually picked.  Also, cameras are not picked
 * as objects, and thus do not typically appear as a terminal object.
 *
 * <P>The path also encapsulates a transform, indicating the
 * composited transform from the top-level camera to the terminal
 * object, possibly going through zero or more internal cameras.  Even
 * when the terminal object is null, the transform contains the
 * complete transform through all the cameras that the mouse pointer
 * is over (for pick operations).
 *
 * <P>The path also holds a list of the cameras traversed by the path.
 * As with the transform, even if the terminal object is null, the
 * camea list contains all the cameras the mouse pointer is over (for
 * pick operations).
 *
 * <P>
 * <b>Warning:</b> Serialized and ZSerialized objects of this class will not be
 * compatible with future Jazz releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running the
 * same version of Jazz. A future release of Jazz will provide support for long
 * term persistence.
 *
 * @see ZDrawingSurface#pick
 * @author Jonathan Meyer, Aug 99
 * @author Ben Bederson */
public final class ZSceneGraphPath implements Serializable {
				// Better to overallocate a bit, and reduce the possibility of dynamic re-allocation
    static private final int INITIAL_PATH_LIST_LENGTH = 10;
    static private final int INITIAL_CAMERA_LIST_LENGTH = 1;
    static private final int INITIAL_TRANSFORMER_LIST_LENGTH = 5;

    private ZRoot root = null;	               // Root of the scenegraph
    private ZCamera topCamera = null;          // The top-level camera.  Set even if the path is empty.
    private ZNode topCameraNode = null;        // The node of the top camera.  Set even if the path is empty.
    private ZSceneGraphObject parents[];       // List of objects in path excluding the terminal object
    private int numParents = 0;                // Number of objects in path list
    private ZCamera cameras[];                 // List of cameras in path
    private int numCameras = 0;	               // Number of cameras in camera list
    private ZSceneGraphObject transformers[];  // List of objects in path that transform 
    private int numTransformers = 0;           // Number of transformers
    private ZSceneGraphObject terminal = null; // The terminal object
    private AffineTransform transform = null;  // The cumulative transform of the path, including internal cameras
    private boolean cameraFound = false;       // True if camera has been found on return up recursive pick calls

    /**
     * Constructs a new ZSceneGraphPath.
     */
    public ZSceneGraphPath() {
    	parents = new ZSceneGraphObject[INITIAL_PATH_LIST_LENGTH];
    	cameras = new ZCamera[INITIAL_CAMERA_LIST_LENGTH];
    	transformers = new ZSceneGraphObject[INITIAL_TRANSFORMER_LIST_LENGTH];
	transform = new AffineTransform();
    }

    /**
     * Returns the terminal object in the path. This is
     * either a ZVisualComponent or a ZNode.
     */
    public ZSceneGraphObject getObject() {
        return terminal;
    }

    /**
     * Sets the terminal object in the path.
     */
    public void setObject(ZSceneGraphObject object) {
        terminal = object;
    }

    /**
     * Returns the node associated with the top-level camera in the path.
     * Even if the path is empty, this node is guaranteed to be set.
     */
    public ZNode getTopCameraNode() {
        return topCameraNode;
    }

    /**
     * Sets the node associated with the top-level camera in the path.
     */
    public void setTopCameraNode(ZNode node) {
	topCameraNode = node;
    }

    /**
     * Returns the top-level camera in the path.  This is the first camera that
     * the object was picked within.
     * Even if the path is empty, this camera is guaranteed to be set.
     */
    public ZCamera getTopCamera() {
        return topCamera;
    }

    /**
     * Sets the top-level camera in the path.
     */
    public void setTopCamera(ZCamera camera) {
	topCamera = camera;
    }

    /**
     * Returns the nearest ZNode to the picked object. If the
     * picked object is a ZNode, this simply returns that
     * object. If the picked object is a ZVisualComponent, this
     * returns the first ZNode parent of the component.
     * @return the node.
     */
    public ZNode getNode() {
    	if (terminal instanceof ZVisualComponent) {
    	    for (int i = numParents - 1; i >= 0; i--) {
    	        Object p = parents[i];
    	        if (p instanceof ZNode) return (ZNode)p;
    	    }
    	}
    	        // terminal is either null or a ZNode - safe
    	        // to simply cast it and return it.
        return (ZNode)terminal;
    }

    /**
     * Returns the nearest ZCamera to the picked object.
     * That is, this returns the last camera on the path.
     * If the path is empty, it returns the top-level camera.
     * @return the camera.
     */
    public ZCamera getCamera() {
    	if (terminal instanceof ZCamera) {
	    return (ZCamera)terminal;
	}
	if (numCameras > 0) {
	    return cameras[numCameras - 1];
	} else {
	    return null;
	}
    }

    /**
     * Returns the root node for this path.
     */
    public ZRoot getRoot() { return root; }

    /**
     * Sets the root node for this path.
     */
    public void setRoot(ZRoot root) { this.root = root; }

    /**
     * Returns the transform for this path. This is formed by compositing
     * the all the transforms of the scene graph objects in this path.
     * This resulting transform represents the local coordinate system
     * of the terminal element of this path.  If the path is empty,
     * then the transform contains the concatenated transforms of the
     * cameras the mouse pointer is over (for pick operations).
     */
    public AffineTransform getTransform() { return transform; }

    /**
     * Sets the transform for this path.
     */
    public void setTransform(AffineTransform tm) { this.transform = tm; }

    /**
     * Converts the specified point from screen coordinates to 
     * global coordinates through the top-level camera of this path.
     * @param pt The pt to be transformed
     */
    public void screenToGlobal(Point2D pt) {
	AffineTransform inverseTransform = topCamera.getInverseViewTransform();
	inverseTransform.transform(pt, pt);
    }

    /**
     * Converts the specified rectangle from screen coordinates to 
     * global coordinates through the top-level camera of this path.
     * @param rect The rect to be transformed
     */
    public void screenToGlobal(Rectangle2D rect) {
	AffineTransform inverseTransform = topCamera.getInverseViewTransform();
	ZTransformGroup.transform(rect, inverseTransform);
    }

    /**
     * Converts the specified point from screen coordinates to the
     * local coordinate system of the terminal scene graph object in
     * this path.
     * @param pt The pt to be transformed
     */
    public void screenToLocal(Point2D pt) {
	try {
	    AffineTransform inverseTransform = transform.createInverse();
	    inverseTransform.transform(pt, pt);
	} catch (NoninvertibleTransformException e) {
	    System.out.println(e);
	}
    }

    /**
     * Converts the specified rectangle from screen coordinates to the
     * local coordinate system of the terminal scene graph object in
     * this path.
     * @param rect The rect to be transformed
     */
    public void screenToLocal(Rectangle2D rect) {
	try {
	    AffineTransform inverseTransform = transform.createInverse();
	    ZTransformGroup.transform(rect, inverseTransform);
	} catch (NoninvertibleTransformException e) {
	    System.out.println(e);
	}
    }

    /**
     * Returns the number of internal ZSceneGraphObjects between the root and the terminal object.
     */
    public int getNumParents() { return numParents; }

    /**
     * Returns the i'th scene graph object between the root and the terminal object. The parent
     * at position 0 is closest to the root, and the parent at the last
     * position is closest to the terminal object.
     * @param i The index of the path element to return
     * @return The scene graph object
     */
    public ZSceneGraphObject getParent(int i) {
        if (i >= numParents || i < 0)
	    throw new IndexOutOfBoundsException(
		"Index: "+i+", Size: "+numParents);
	return parents[i];
    }

    /**
     * Adds a node to the end of the list of parent nodes.
     * This is used during picking
     * to construct a path from the root to the picked object.
     * @param sgo The scene graph object to be added to the path
     */
    public void push(ZSceneGraphObject sgo) {
	try {
	    parents[numParents] = sgo;
	} catch (ArrayIndexOutOfBoundsException e) {
    	    int newLen = parents.length * 2;
    	    ZSceneGraphObject tmp[] = new ZSceneGraphObject[newLen];
    	    System.arraycopy(parents, 0, tmp, 0, parents.length);
	    parents = tmp;
	    parents[numParents] = sgo;
    	}
	numParents++;
    }

    /**
     * Removes a node (and any nodes after it) from the list of parent nodes.
     * This is used during picking
     * to construct a path from the root to the picked object.
     * @param sgo The scene graph object to be removed from the path
     */
    public void pop(ZSceneGraphObject sgo) {
    	for (int i = numParents - 1; i >= 0; i--) {
	    if (parents[i] == sgo) {
	        numParents = i;
	        return;
	    }
	}
        throw new IllegalArgumentException(sgo + " is not on path.");
    }

    /**
     * Trims the capacity of the array that stores the parents list points to
     * the actual number of points.  Normally, the parents list arrays can be
     * slightly larger than the number of points in the parents list.
     * An application can use this operation to minimize the storage of a
     * parents list.
     */
    public void trimToSize() {
	ZSceneGraphObject[] newParents = new ZSceneGraphObject[numParents];
	for (int i=0; i<numParents; i++) {
	    newParents[i] = parents[i];
	}
	parents = newParents;
    }

    /**
     * Returns the number of internal cameras between the root and the terminal object.
     */
    public int getNumCameras() { return numCameras; }

    /**
     * Returns the i'th camera between the root and the terminal object. The camera
     * at position 0 is closest to the root, and the camera at the last
     * position is closest to the terminal object.
     * @param i The index of the camera to return
     * @return The camera
     */
    public ZCamera getCamera(int i) {
        if (i >= numCameras || i < 0)
	    throw new IndexOutOfBoundsException(
		"Index: "+i+", Size: "+numCameras);
	return cameras[i];
    }

    /**
     * Adds a node to the end of the list of camera nodes.
     * This is used during picking
     * to construct a path from the root to the picked object.
     * @param camera The camera to be added to the path
     */
    public void pushCamera(ZCamera camera) {
	try {
	    cameras[numCameras] = camera;
	} catch (ArrayIndexOutOfBoundsException e) {
    	    int newLen = cameras.length * 2;
    	    ZCamera tmp[] = new ZCamera[newLen];
    	    System.arraycopy(cameras, 0, tmp, 0, cameras.length);
	    cameras = tmp;
	    cameras[numCameras] = camera;
    	}
	numCameras++;
    }

    /**
     * Removes a camera (and any cameras after it) from the list of camera nodes.
     * This is used
     * to construct a path from the root to the picked object.
     * @param camera The camera to be removed from the path
     */
    public void popCamera(ZCamera camera) {
    	for (int i = numCameras - 1; i >= 0; i--) {
	    if (cameras[i] == camera) {
	        numCameras = i;
	        return;
	    }
	}
        throw new IllegalArgumentException(camera + " is not on path.");
    }

    /**
     * Trims the capacity of the array that stores the cameras to
     * the actual number of points.  Normally, the cameras array can be
     * slightly larger than the number of cameras in the list.
     * An application can use this operation to minimize the storage of the
     * camera list.
     */
    public void trimCamerasToSize() {
	ZCamera[] newCameras = new ZCamera[numCameras];
	for (int i=0; i<numCameras; i++) {
	    newCameras[i] = cameras[i];
	}
	cameras = newCameras;
    }

    /**
     * Internal method.
     * Adds a transformer to the end of the list of transformer nodes.
     * This is used to support updateTransform().
     * @param transformer The transformer to be added to the path
     */
    public void pushTransformer(ZSceneGraphObject transformer) {
	try {
	    transformers[numTransformers] = transformer;
	} catch (ArrayIndexOutOfBoundsException e) {
    	    int newLen = transformers.length * 2;
    	    ZSceneGraphObject tmp[] = new ZSceneGraphObject[newLen];
    	    System.arraycopy(transformers, 0, tmp, 0, transformers.length);
	    transformers = tmp;
	    transformers[numTransformers] = transformer;
    	}
	numTransformers++;
    }

    /**
     * Removes a transformer (and any transformers after it) from the list of transformer nodes.
     * This is used to support updateTransform().
     * @param transformer The transformer to be removed from the path
     */
    public void popTransformer(ZSceneGraphObject transformer) {
    	for (int i = numTransformers - 1; i >= 0; i--) {
	    if (transformers[i] == transformer) {
	        numTransformers = i;
	        return;
	    }
	}
        throw new IllegalArgumentException(transformer + " is not on path.");
    }

    /**
     * Trims the capacity of the array that stores the transformers to
     * the actual number of points.  Normally, the transformers array can be
     * slightly larger than the number of transformers in the list.
     * An application can use this operation to minimize the storage of the
     * transformer list.
     */
    public void trimTransformersToSize() {
	ZSceneGraphObject[] newTransformers = new ZSceneGraphObject[numTransformers];
	for (int i=0; i<numTransformers; i++) {
	    newTransformers[i] = transformers[i];
	}
	transformers = newTransformers;
    }

    /**
     * Internal method.  This is used by pick on the way back up
     * the recursive pick checking to say that a camera has been gone
     * through, and thus transforms should be kept from this point up.
     */
    public void setCameraFound(boolean cf) {
	cameraFound = cf;
    }

    /**
     * Internal method.  This is used by pick on the way back up
     * the recursive pick checking to say that a camera has been gone
     * through, and thus transforms should be kept from this point up.
     */
    public boolean getCameraFound() {
	return cameraFound;
    }

    /**
     * Update the path's transform.  This will modify the transform by
     * going through the path and rebuilding the transform based on
     * current values of ZCamera and ZTransformGroup objects.
     */
    public void updateTransform() {
	ZSceneGraphObject obj;
	AffineTransform tmpTransform = new AffineTransform();

	for (int i=0; i<numTransformers; i++) {
	    obj = transformers[i];
	    if (obj instanceof ZCamera) {
		tmpTransform.concatenate(((ZCamera)obj).getViewTransform());
	    } else if (obj instanceof ZTransformGroup) {
		tmpTransform.concatenate(((ZTransformGroup)obj).getTransform());
	    }
	}

	setTransform(tmpTransform);
    }

    /**
     * Returns a string description of this path useful for debugging.
     * @return the string
     */
    public String toString() {
    	StringBuffer sb = new StringBuffer();
    	sb.append("ZSceneGraphPath[transform=" + transform
    	    + "; root=" + getRoot() + "; object=" + getObject() + "; parents=");
    	for (int i = 0; i < numParents; i++) {
    	    sb.append(parents[i]);
    	    if (i < numParents - 1) sb.append(", ");
    	}
	sb.append("; cameras=");
    	for (int i = 0; i < numCameras; i++) {
    	    sb.append(cameras[i]);
    	    if (i < numCameras - 1) sb.append(", ");
    	}
    	sb.append("]");
    	return sb.toString();
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
	trimToSize();   // Remove extra unused array elements
	trimCamerasToSize();
	out.defaultWriteObject();
    }
}
